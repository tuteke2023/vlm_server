/**
 * VLM Server Web Interface
 * Main application logic for the document intelligence platform
 */

class VLMApp {
    constructor() {
        // Dynamically determine server URL based on current location
        const currentHost = window.location.hostname;
        this.serverUrl = currentHost === 'localhost' || currentHost === '127.0.0.1' 
            ? 'http://localhost:8000'
            : `http://${currentHost}:8000`;
        
        this.currentTool = 'bank-transactions';
        this.uploadedFiles = new Map();
        this.isProcessing = false;
        
        this.currentQuantization = 'none';
        
        // Provider management
        this.currentProvider = 'local';
        this.providers = {
            local: { available: false, name: 'Local VLM' },
            openai: { available: false, name: 'OpenAI GPT-4V' }
        };
        
        // Privacy modal
        this.privacyModal = new PrivacyModal(this);
        
        this.init();
    }
    
    init() {
        this.setupEventListeners();
        this.checkServerStatus();
        this.updateVramStatus();
        this.updateDetailedVramStatus();
        this.loadAvailableModels();
        this.loadProviders();
        
        // Set audio transcription link dynamically
        const audioLink = document.getElementById('audioTranscriptionLink');
        if (audioLink) {
            const currentHost = window.location.hostname;
            const audioUrl = currentHost === 'localhost' || currentHost === '127.0.0.1' 
                ? 'http://localhost:8002'
                : `http://${currentHost}:8002`;
            audioLink.href = audioUrl;
        }
        
        // Update server status every 30 seconds
        setInterval(() => {
            this.checkServerStatus();
            this.updateVramStatus();
            this.updateDetailedVramStatus();
        }, 30000);
    }
    
    async loadProviders() {
        try {
            const response = await fetch(`${this.serverUrl}/api/v1/providers`);
            if (response.ok) {
                const data = await response.json();
                this.currentProvider = data.current_provider;
                this.providers.local.available = data.available_providers.local;
                this.providers.openai.available = data.available_providers.openai;
                
                // Update UI
                const providerSelect = document.getElementById('providerSelect');
                providerSelect.value = this.currentProvider;
                
                // Enable/disable options based on availability
                providerSelect.querySelector('option[value="local"]').disabled = !this.providers.local.available;
                providerSelect.querySelector('option[value="openai"]').disabled = !this.providers.openai.available;
                
                this.updateProviderIndicator();
            }
        } catch (error) {
            console.error('Failed to load providers:', error);
        }
    }
    
    updateProviderIndicator() {
        const indicator = document.getElementById('providerIndicator');
        if (this.currentProvider === 'openai') {
            indicator.className = 'provider-indicator openai';
            indicator.innerHTML = '<i class="fas fa-cloud"></i> <span>OpenAI</span>';
        } else {
            indicator.className = 'provider-indicator local';
            indicator.innerHTML = '<i class="fas fa-lock"></i> <span>Local</span>';
        }
    }
    
    setupEventListeners() {
        // Tool navigation
        document.querySelectorAll('.menu-item').forEach(item => {
            item.addEventListener('click', (e) => {
                const tool = e.currentTarget.dataset.tool;
                this.switchTool(tool);
            });
        });
        
        // Upload areas
        this.setupUploadHandlers();
        
        // Process button
        document.getElementById('processBtn').addEventListener('click', () => {
            this.processFiles();
        });
        
        // Provider selector
        document.getElementById('providerSelect').addEventListener('change', async (e) => {
            await this.handleProviderChange(e.target.value);
        });
        
        // Quick actions
        document.getElementById('clearVramBtn').addEventListener('click', () => {
            this.clearVram();
        });
        
        document.getElementById('exportResultsBtn').addEventListener('click', () => {
            this.exportResults();
        });
        
        // Model settings
        document.getElementById('reloadModelBtn').addEventListener('click', () => {
            this.reloadModel();
        });
        
        // Quantization is disabled
        // document.getElementById('quantizationSelect').addEventListener('change', (e) => {
        //     this.updateQuantizationInfo(e.target.value);
        // });
        
        document.getElementById('modelSelect').addEventListener('change', (e) => {
            this.updateModelInfo(e.target.value);
        });
        
        // Result actions
        document.getElementById('copyResultBtn').addEventListener('click', () => {
            this.copyResults();
        });
        
        document.getElementById('downloadResultBtn').addEventListener('click', () => {
            this.downloadResults();
        });
        
        // Example query tags
        document.querySelectorAll('.example-tag').forEach(tag => {
            tag.addEventListener('click', (e) => {
                const query = e.target.dataset.query;
                document.getElementById('customQuery').value = query;
            });
        });
    }
    
    setupUploadHandlers() {
        const uploadAreas = [
            'bankUploadArea', 'docUploadArea', 'imageUploadArea', 
            'textUploadArea', 'customUploadArea'
        ];
        
        const fileInputs = [
            'bankFileInput', 'docFileInput', 'imageFileInput',
            'textFileInput', 'customFileInput'
        ];
        
        uploadAreas.forEach((areaId, index) => {
            const area = document.getElementById(areaId);
            const input = document.getElementById(fileInputs[index]);
            
            // Click to browse
            area.addEventListener('click', () => input.click());
            
            // Drag and drop
            area.addEventListener('dragover', (e) => {
                e.preventDefault();
                area.classList.add('dragover');
            });
            
            area.addEventListener('dragleave', () => {
                area.classList.remove('dragover');
            });
            
            area.addEventListener('drop', (e) => {
                e.preventDefault();
                area.classList.remove('dragover');
                this.handleFiles(e.dataTransfer.files, areaId);
            });
            
            // File input change
            input.addEventListener('change', (e) => {
                this.handleFiles(e.target.files, areaId);
            });
        });
    }
    
    switchTool(tool) {
        // Update navigation
        document.querySelectorAll('.menu-item').forEach(item => {
            item.classList.remove('active');
        });
        document.querySelector(`[data-tool="${tool}"]`).classList.add('active');
        
        // Update content
        document.querySelectorAll('.tool-panel').forEach(panel => {
            panel.classList.remove('active');
        });
        document.getElementById(tool).classList.add('active');
        
        this.currentTool = tool;
        this.clearFiles();
        this.hideResults();
    }
    
    async checkServerStatus() {
        try {
            const response = await fetch(`${this.serverUrl}/health`);
            const data = await response.json();
            
            const statusElement = document.getElementById('serverStatus');
            const statusDot = statusElement.querySelector('.status-dot');
            const statusText = statusElement.querySelector('.status-text');
            
            if (data.status === 'healthy') {
                statusDot.className = 'status-dot online';
                statusText.textContent = `Online (${data.device})`;
            } else {
                statusDot.className = 'status-dot offline';
                statusText.textContent = 'Server Error';
            }
        } catch (error) {
            const statusElement = document.getElementById('serverStatus');
            const statusDot = statusElement.querySelector('.status-dot');
            const statusText = statusElement.querySelector('.status-text');
            
            statusDot.className = 'status-dot offline';
            statusText.textContent = 'Offline';
        }
    }
    
    async updateVramStatus() {
        try {
            const response = await fetch(`${this.serverUrl}/vram_status`);
            const data = await response.json();
            
            const vramElement = document.getElementById('vramUsage');
            const usageText = `${data.usage_percentage.toFixed(1)}% (${data.allocated_gb.toFixed(1)}GB/${data.total_gb.toFixed(1)}GB)`;
            vramElement.querySelector('span').textContent = `VRAM: ${usageText}`;
        } catch (error) {
            console.error('Failed to update VRAM status:', error);
        }
    }
    
    async updateDetailedVramStatus() {
        try {
            const response = await fetch(`${this.serverUrl}/vram_status`);
            const data = await response.json();
            
            // Update VRAM bar
            const vramBar = document.getElementById('vramBar');
            const vramText = document.getElementById('vramText');
            const vramDetails = document.getElementById('vramDetails');
            
            vramBar.style.width = `${data.usage_percentage}%`;
            vramText.textContent = `${data.usage_percentage.toFixed(1)}%`;
            vramDetails.textContent = `${data.allocated_gb.toFixed(1)}GB / ${data.total_gb.toFixed(1)}GB allocated`;
            
            // Update color based on usage
            vramBar.className = 'vram-fill';
            if (data.usage_percentage >= 90) {
                vramBar.classList.add('danger');
            } else if (data.usage_percentage >= 75) {
                vramBar.classList.add('warning');
            }
            
        } catch (error) {
            console.error('Failed to update detailed VRAM status:', error);
            const vramDetails = document.getElementById('vramDetails');
            vramDetails.textContent = 'Failed to load VRAM status';
        }
    }
    
    // Quantization options removed - functionality disabled
    
    async loadAvailableModels() {
        try {
            const response = await fetch(`${this.serverUrl}/available_models`);
            const models = await response.json();
            
            const select = document.getElementById('modelSelect');
            select.innerHTML = '';
            
            models.forEach(model => {
                const option = document.createElement('option');
                option.value = model.model_id;
                option.textContent = `${model.size} - ${model.description} (~${model.vram_gb}GB VRAM)`;
                if (model.is_current) {
                    option.selected = true;
                    this.updateModelInfo(model.model_id, model);
                    // Update the results section model display
                    const currentModelDisplay = document.getElementById('currentModelDisplay');
                    if (currentModelDisplay) {
                        currentModelDisplay.textContent = model.name;
                    }
                }
                select.appendChild(option);
            });
            
        } catch (error) {
            console.error('Failed to load available models:', error);
        }
    }
    
    updateModelInfo(modelId, modelData = null) {
        const info = document.getElementById('modelInfo');
        
        if (modelData) {
            info.innerHTML = `<small>Current: ${modelData.size} (~${modelData.vram_gb}GB VRAM)</small>`;
        } else {
            // Find model info from select options
            const select = document.getElementById('modelSelect');
            const selectedOption = select.querySelector(`option[value="${modelId}"]`);
            if (selectedOption) {
                info.innerHTML = `<small>Selected: ${selectedOption.textContent}</small>`;
            }
        }
    }
    
    // Quantization info removed - functionality disabled
    
    async reloadModel() {
        const modelName = document.getElementById('modelSelect').value;
        const reloadBtn = document.getElementById('reloadModelBtn');
        
        try {
            reloadBtn.disabled = true;
            reloadBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Reloading...';
            
            this.showToast('Reloading model with new settings...', 'info');
            
            const response = await fetch(`${this.serverUrl}/reload_model`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    model_name: modelName
                })
            });
            
            if (response.ok) {
                const result = await response.json();
                this.showToast(`Model switched successfully to ${result.current_model.split('/').pop()}`, 'success');
                
                // Update current model display
                const currentModelDisplay = document.getElementById('currentModelDisplay');
                if (currentModelDisplay) {
                    currentModelDisplay.textContent = result.current_model.split('/').pop();
                }
                
                // Update VRAM status after reload
                setTimeout(() => {
                    this.updateVramStatus();
                    this.updateDetailedVramStatus();
                    this.loadAvailableModels(); // Refresh model selection
                }, 2000);
            } else {
                const error = await response.json();
                this.showToast(`Failed to reload model: ${error.detail}`, 'error');
            }
            
        } catch (error) {
            this.showToast(`Error reloading model: ${error.message}`, 'error');
        } finally {
            reloadBtn.disabled = false;
            reloadBtn.innerHTML = '<i class="fas fa-sync-alt"></i> Switch Model';
        }
    }
    
    async predictVramUsage(inputTokens, outputTokens) {
        try {
            const response = await fetch(`${this.serverUrl}/vram_prediction?input_tokens=${inputTokens}&output_tokens=${outputTokens}`);
            return await response.json();
        } catch (error) {
            console.error('Failed to predict VRAM usage:', error);
            return null;
        }
    }
    
    handleFiles(files, uploadAreaId) {
        const fileArray = Array.from(files);
        
        fileArray.forEach(file => {
            if (this.validateFile(file)) {
                this.uploadedFiles.set(file.name, {
                    file: file,
                    uploadArea: uploadAreaId
                });
            }
        });
        
        this.displayFiles();
        this.updateProcessButton();
    }
    
    validateFile(file) {
        const maxSize = 50 * 1024 * 1024; // 50MB
        const allowedTypes = [
            'application/pdf',
            'image/png', 'image/jpeg', 'image/jpg', 'image/gif',
            'text/plain'
        ];
        
        if (file.size > maxSize) {
            this.showToast('File too large. Maximum size is 50MB.', 'error');
            return false;
        }
        
        if (!allowedTypes.includes(file.type)) {
            this.showToast('Unsupported file type.', 'error');
            return false;
        }
        
        return true;
    }
    
    displayFiles() {
        const uploadArea = document.querySelector(`#${this.currentTool} .upload-area`);
        let previewContainer = uploadArea.parentNode.querySelector('.file-preview');
        
        if (!previewContainer) {
            previewContainer = document.createElement('div');
            previewContainer.className = 'file-preview';
            uploadArea.parentNode.insertBefore(previewContainer, uploadArea.nextSibling);
        }
        
        previewContainer.innerHTML = '';
        
        this.uploadedFiles.forEach((fileData, fileName) => {
            const fileItem = document.createElement('div');
            fileItem.className = 'file-item';
            
            const fileIcon = this.getFileIcon(fileData.file.type);
            const fileSize = this.formatFileSize(fileData.file.size);
            
            fileItem.innerHTML = `
                <div class="file-icon">
                    <i class="${fileIcon}"></i>
                </div>
                <div class="file-info">
                    <div class="file-name">${fileName}</div>
                    <div class="file-size">${fileSize}</div>
                </div>
                <button class="file-remove" onclick="app.removeFile('${fileName}')">
                    <i class="fas fa-times"></i>
                </button>
            `;
            
            previewContainer.appendChild(fileItem);
        });
    }
    
    getFileIcon(fileType) {
        if (fileType.includes('pdf')) return 'fas fa-file-pdf';
        if (fileType.includes('image')) return 'fas fa-file-image';
        if (fileType.includes('text')) return 'fas fa-file-alt';
        return 'fas fa-file';
    }
    
    formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
    
    removeFile(fileName) {
        this.uploadedFiles.delete(fileName);
        this.displayFiles();
        this.updateProcessButton();
    }
    
    updateProcessButton() {
        const processBtn = document.getElementById('processBtn');
        const hasFiles = this.uploadedFiles.size > 0;
        const hasQuery = this.currentTool === 'custom-query' && 
                        document.getElementById('customQuery').value.trim() !== '';
        
        if (this.currentTool === 'custom-query') {
            processBtn.disabled = !hasFiles || !hasQuery;
        } else {
            processBtn.disabled = !hasFiles;
        }
    }
    
    async handleProviderChange(newProvider) {
        try {
            const response = await fetch(`${this.serverUrl}/api/v1/set_provider`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ provider: newProvider })
            });
            
            if (response.ok) {
                const result = await response.json();
                this.currentProvider = newProvider;
                this.updateProviderIndicator();
                this.showToast(`Switched to ${this.providers[newProvider].name}`, 'success');
            } else {
                const error = await response.json();
                this.showToast(`Failed to switch provider: ${error.detail}`, 'error');
                // Revert selection
                document.getElementById('providerSelect').value = this.currentProvider;
            }
        } catch (error) {
            this.showToast(`Error switching provider: ${error.message}`, 'error');
            // Revert selection
            document.getElementById('providerSelect').value = this.currentProvider;
        }
    }
    
    isSensitiveDocument() {
        // Check if current tool or content suggests sensitive data
        const sensitiveTools = ['bank-transactions'];
        const sensitiveKeywords = ['bank', 'ssn', 'medical', 'tax', 'financial', 'account'];
        
        if (sensitiveTools.includes(this.currentTool)) {
            return true;
        }
        
        // Check custom query for sensitive keywords
        if (this.currentTool === 'custom-query') {
            const query = document.getElementById('customQuery').value.toLowerCase();
            return sensitiveKeywords.some(keyword => query.includes(keyword));
        }
        
        return false;
    }
    
    async processFiles() {
        if (this.isProcessing || this.uploadedFiles.size === 0) return;
        
        // Check for sensitive content with OpenAI provider
        if (this.currentProvider === 'openai' && this.isSensitiveDocument()) {
            const userConsent = await this.privacyModal.show();
            if (!userConsent) {
                return; // User cancelled or chose to use local VLM
            }
        }
        
        // VRAM safety check if enabled (only for local provider)
        if (this.currentProvider === 'local' && document.getElementById('enableSafetyCheck').checked) {
            const maxTokens = this.getMaxTokens();
            const prediction = await this.predictVramUsage(512, maxTokens);
            
            if (prediction && !prediction.is_safe) {
                const message = `VRAM safety check failed. Predicted usage: ${prediction.predicted_percentage.toFixed(1)}% (limit: 90%). Try switching to the 3B model for lower VRAM usage.`;
                this.showToast(message, 'warning');
                return;
            }
        }
        
        this.isProcessing = true;
        this.showProgress();
        
        try {
            const results = [];
            let fileIndex = 0;
            
            for (const [fileName, fileData] of this.uploadedFiles) {
                fileIndex++;
                this.updateProgress((fileIndex / this.uploadedFiles.size) * 100, 
                                  `Processing ${fileName}...`);
                
                const result = await this.processFile(fileData.file);
                results.push({
                    fileName: fileName,
                    result: result,
                    file: fileData.file  // Store file for CSV export
                });
            }
            
            this.displayResults(results);
            this.showToast('Processing completed successfully!', 'success');
            
        } catch (error) {
            console.error('Processing error:', error);
            
            // Check if it's an OpenAI error and we're using OpenAI
            if (this.currentProvider === 'openai' && 
                (error.message.includes('OpenAI') || error.message.includes('API error') || 
                 error.message.includes('Falling back to local VLM'))) {
                
                const useFallback = await this.showFallbackConfirmation();
                if (useFallback) {
                    // Switch to local provider and retry
                    this.showToast('Switching to local VLM...', 'info');
                    await this.handleProviderChange('local');
                    this.hideProgress();
                    this.isProcessing = false;
                    
                    // Retry the same operation with local VLM
                    return this.processFiles();
                } else {
                    this.showToast('Processing cancelled', 'warning');
                }
            } else {
                let errorMessage = error.message;
                
                // Handle VRAM safety errors specially
                if (error.message.includes('VRAM safety check failed')) {
                    errorMessage = 'VRAM usage would be too high. Try switching to the 3B model or reducing max tokens.';
                }
                
                this.showToast(`Processing failed: ${errorMessage}`, 'error');
            }
        } finally {
            this.isProcessing = false;
            this.hideProgress();
            
            // Update VRAM status after processing
            setTimeout(() => {
                this.updateVramStatus();
                this.updateDetailedVramStatus();
            }, 1000);
        }
    }
    
    async processFile(file) {
        const base64 = await this.fileToBase64(file);
        const prompt = this.generatePrompt();
        
        const messages = [{
            role: 'user',
            content: [
                {
                    type: 'image',
                    image: base64
                },
                {
                    type: 'text',
                    text: prompt
                }
            ]
        }];
        
        // Use bank extraction endpoint for bank transactions
        const endpoint = this.currentTool === 'bank-transactions' 
            ? `${this.serverUrl}/api/v1/bank_extract_json`
            : `${this.serverUrl}/api/v1/generate`;
            
        const requestBody = this.currentTool === 'bank-transactions'
            ? { 
                messages: messages,
                max_new_tokens: this.getMaxTokens(),  // Pass max tokens for bank extraction too
                temperature: 0.1  // Lower temperature for more consistent extraction
            }
            : {
                messages: messages,
                max_new_tokens: this.getMaxTokens(),
                temperature: 0.7,
                enable_safety_check: document.getElementById('enableSafetyCheck').checked
            };
        
        const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestBody)
        });
        
        if (!response.ok) {
            const errorData = await response.json().catch(() => ({ detail: 'Unknown error' }));
            throw new Error(errorData.detail || `Server error: ${response.status}`);
        }
        
        return await response.json();
    }
    
    fileToBase64(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onload = () => resolve(reader.result);
            reader.onerror = error => reject(error);
        });
    }
    
    formatBankTransactions(data) {
        let output = 'Bank Statement Analysis\n';
        output += '======================\n\n';
        
        if (data.account_number) {
            output += `Account Number: ${data.account_number}\n`;
        }
        if (data.statement_period) {
            output += `Statement Period: ${data.statement_period}\n`;
        }
        output += `\nTotal Transactions: ${data.transaction_count || 0}\n`;
        output += `Total Debits: $${(data.total_debits || 0).toFixed(2)}\n`;
        output += `Total Credits: $${(data.total_credits || 0).toFixed(2)}\n\n`;
        
        output += 'Transactions:\n';
        output += '-------------\n';
        output += 'Date\t\tDescription\t\t\t\tDebit\t\tCredit\t\tBalance\n';
        
        if (data.transactions && data.transactions.length > 0) {
            data.transactions.forEach(tx => {
                const date = tx.date || '';
                const desc = (tx.description || '').substring(0, 40).padEnd(40, ' ');
                const debit = tx.debit ? `$${tx.debit.toFixed(2)}` : '';
                const credit = tx.credit ? `$${tx.credit.toFixed(2)}` : '';
                const balance = tx.balance ? `$${tx.balance.toFixed(2)}` : '';
                
                output += `${date}\t${desc}\t${debit}\t\t${credit}\t\t${balance}\n`;
            });
        }
        
        return output;
    }
    
    generatePrompt() {
        switch (this.currentTool) {
            case 'bank-transactions':
                return this.generateBankTransactionPrompt();
            case 'document-summary':
                return this.generateDocumentSummaryPrompt();
            case 'image-analysis':
                return this.generateImageAnalysisPrompt();
            case 'text-extraction':
                return this.generateTextExtractionPrompt();
            case 'custom-query':
                return document.getElementById('customQuery').value;
            default:
                return 'Please analyze this document or image.';
        }
    }
    
    generateBankTransactionPrompt() {
        const options = [];
        if (document.getElementById('extractDates').checked) options.push('transaction dates');
        if (document.getElementById('extractAmounts').checked) options.push('amounts');
        if (document.getElementById('extractDescriptions').checked) options.push('descriptions');
        if (document.getElementById('extractBalances').checked) options.push('running balances');
        if (document.getElementById('categorizeTransactions').checked) options.push('transaction categories');
        if (document.getElementById('detectMerchants').checked) options.push('merchant names');
        
        return `Analyze this bank statement or transaction document and extract the following information in a structured format: ${options.join(', ')}. 
                Present the data in a clear table format with proper headers. 
                If you find multiple transactions, list each one separately. 
                Also provide a summary of total debits, credits, and account balance if available.`;
    }
    
    generateDocumentSummaryPrompt() {
        const length = document.getElementById('summaryLength').value;
        const style = document.getElementById('summaryStyle').value;
        const extractKeyPoints = document.getElementById('extractKeyPoints').checked;
        const identifyEntities = document.getElementById('identifyEntities').checked;
        
        let prompt = `Provide a ${length} summary of this document in ${style} style.`;
        
        if (extractKeyPoints) {
            prompt += ' Include key points and main topics.';
        }
        
        if (identifyEntities) {
            prompt += ' Identify important names, dates, locations, and organizations mentioned.';
        }
        
        return prompt;
    }
    
    generateImageAnalysisPrompt() {
        const options = [];
        if (document.getElementById('describeImage').checked) options.push('detailed description');
        if (document.getElementById('identifyObjects').checked) options.push('object identification');
        if (document.getElementById('readText').checked) options.push('text extraction (OCR)');
        if (document.getElementById('analyzeColors').checked) options.push('color analysis');
        if (document.getElementById('detectFaces').checked) options.push('face detection');
        if (document.getElementById('identifyLandmarks').checked) options.push('landmark recognition');
        
        return `Analyze this image and provide: ${options.join(', ')}. 
                Be comprehensive and detailed in your analysis.`;
    }
    
    generateTextExtractionPrompt() {
        const preserveFormatting = document.getElementById('preserveFormatting').checked;
        const detectTables = document.getElementById('detectTables').checked;
        const extractHeaders = document.getElementById('extractHeaders').checked;
        const cleanText = document.getElementById('cleanText').checked;
        
        let prompt = 'Extract all text from this image or document.';
        
        if (preserveFormatting) prompt += ' Preserve the original formatting and structure.';
        if (detectTables) prompt += ' Identify and properly format any tables.';
        if (extractHeaders) prompt += ' Highlight headers and section titles.';
        if (cleanText) prompt += ' Clean up and properly format the extracted text.';
        
        return prompt;
    }
    
    getMaxTokens() {
        switch (this.currentTool) {
            case 'bank-transactions':
                return 3000;  // Increased to handle full bank statements
            case 'document-summary':
                const length = document.getElementById('summaryLength').value;
                return length === 'brief' ? 200 : length === 'medium' ? 500 : 1000;
            case 'image-analysis':
                return 800;
            case 'text-extraction':
                return 1500;
            case 'custom-query':
                return 1000;
            default:
                return 500;
        }
    }
    
    displayResults(results) {
        const resultsSection = document.getElementById('resultsSection');
        const resultsContent = document.getElementById('resultsContent');
        
        resultsSection.style.display = 'block';
        
        let combinedResults = '';
        let totalTokens = 0;
        let totalTime = 0;
        
        // Store results for potential bank export
        this.lastResults = results;
        
        results.forEach((result, index) => {
            combinedResults += `=== ${result.fileName} ===\n\n`;
            
            // Check for metadata warnings
            if (result.result.metadata) {
                if (result.result.metadata.provider) {
                    combinedResults += `[Provider: ${result.result.metadata.provider}]\n`;
                }
                if (result.result.metadata.estimated_cost) {
                    combinedResults += `[Estimated Cost: ${result.result.metadata.estimated_cost}]\n`;
                }
                if (result.result.metadata.sensitivity_check && result.result.metadata.sensitivity_check.is_sensitive) {
                    combinedResults += `⚠️ Sensitive content detected\n`;
                }
                combinedResults += '\n';
            }
            
            // Handle bank extraction response differently
            if (this.currentTool === 'bank-transactions' && result.result.data) {
                const data = result.result.data;
                combinedResults += this.formatBankTransactions(data);
                totalTime += result.result.processing_time || 0;
            } else {
                combinedResults += result.result.response || JSON.stringify(result.result, null, 2);
                combinedResults += '\n\n';
                
                if (result.result.usage) {
                    totalTokens += result.result.usage.total_tokens;
                }
                totalTime += result.result.processing_time || 0;
            }
        });
        
        resultsContent.textContent = combinedResults;
        
        // Update processing info
        document.getElementById('processingTime').textContent = `${totalTime.toFixed(2)}s`;
        document.getElementById('tokensUsed').textContent = totalTokens.toString();
        
        // Update model info from metadata
        if (results.length > 0 && results[0].result.metadata) {
            const metadata = results[0].result.metadata;
            const modelDisplay = document.getElementById('modelUsed');
            if (modelDisplay) {
                modelDisplay.textContent = metadata.model || metadata.provider || 'Unknown';
            }
        }
        
        // Show CSV export button if this is a bank transaction
        const exportCsvBtn = document.getElementById('exportCsvBtn');
        if (this.currentTool === 'bank-transactions' && exportCsvBtn) {
            exportCsvBtn.style.display = 'inline-flex';
        } else if (exportCsvBtn) {
            exportCsvBtn.style.display = 'none';
        }
        
        // Scroll to results
        resultsSection.scrollIntoView({ behavior: 'smooth' });
    }
    
    showProgress() {
        const processBtn = document.getElementById('processBtn');
        const progressContainer = document.getElementById('progressContainer');
        
        processBtn.disabled = true;
        processBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> <span>Processing...</span>';
        progressContainer.style.display = 'block';
    }
    
    hideProgress() {
        const processBtn = document.getElementById('processBtn');
        const progressContainer = document.getElementById('progressContainer');
        
        processBtn.disabled = false;
        processBtn.innerHTML = '<i class="fas fa-play"></i> <span>Start Processing</span>';
        progressContainer.style.display = 'none';
        
        this.updateProcessButton(); // Re-check if button should be disabled
    }
    
    updateProgress(percentage, text) {
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        
        progressFill.style.width = `${percentage}%`;
        progressText.textContent = text;
    }
    
    hideResults() {
        document.getElementById('resultsSection').style.display = 'none';
    }
    
    clearFiles() {
        this.uploadedFiles.clear();
        
        // Clear file previews
        document.querySelectorAll('.file-preview').forEach(preview => {
            preview.remove();
        });
        
        // Reset file inputs
        document.querySelectorAll('input[type=\"file\"]').forEach(input => {
            input.value = '';
        });
        
        this.updateProcessButton();
    }
    
    async clearVram() {
        try {
            const response = await fetch(`${this.serverUrl}/clear_vram`, {
                method: 'POST'
            });
            
            if (response.ok) {
                this.showToast('VRAM cleared successfully', 'success');
                this.updateVramStatus();
            } else {
                this.showToast('Failed to clear VRAM', 'error');
            }
        } catch (error) {
            this.showToast('Error clearing VRAM', 'error');
        }
    }
    
    copyResults() {
        const resultsContent = document.getElementById('resultsContent');
        navigator.clipboard.writeText(resultsContent.textContent).then(() => {
            this.showToast('Results copied to clipboard', 'success');
        }).catch(() => {
            this.showToast('Failed to copy results', 'error');
        });
    }
    
    downloadResults() {
        const resultsContent = document.getElementById('resultsContent');
        const content = resultsContent.textContent;
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const filename = `vlm-results-${timestamp}.txt`;
        
        const blob = new Blob([content], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
        
        this.showToast('Results downloaded successfully', 'success');
    }
    
    async exportBankStatementCsv() {
        if (!this.lastResults || this.lastResults.length === 0) {
            this.showToast('No results to export', 'error');
            return;
        }
        
        try {
            this.showToast('Generating CSV export...', 'info');
            
            // Use the same prompt and content that was used for processing
            const fileInfo = this.lastResults[0];
            const prompt = this.generateBankTransactionPrompt();
            
            let content;
            if (fileInfo.file && fileInfo.file.type.startsWith('image/')) {
                // For images, convert to base64 again
                const base64 = await this.fileToBase64(fileInfo.file);
                content = [
                    {
                        type: "image",
                        image: base64
                    },
                    {
                        type: "text",
                        text: prompt
                    }
                ];
            } else {
                // For text files, just use the response text
                content = prompt + "\n\nBank Statement:\n" + fileInfo.result.response;
            }
            
            const messages = [{
                role: 'user',
                content: content
            }];
            
            const response = await fetch(`${this.serverUrl}/api/v1/bank_export`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    messages: messages,
                    export_format: 'csv'
                })
            });
            
            if (!response.ok) {
                throw new Error('Failed to export bank statement');
            }
            
            const data = await response.json();
            
            // Download the CSV
            const blob = new Blob([data.content], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = data.filename;
            a.click();
            URL.revokeObjectURL(url);
            
            this.showToast(`Exported ${data.transaction_count} transactions to CSV`, 'success');
            
        } catch (error) {
            console.error('Export error:', error);
            this.showToast('Failed to export CSV', 'error');
        }
    }
    
    exportResults() {
        if (document.getElementById('resultsSection').style.display === 'none') {
            this.showToast('No results to export', 'warning');
            return;
        }
        
        this.downloadResults();
    }
    
    showToast(message, type = 'info') {
        const toastContainer = document.getElementById('toastContainer');
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        
        const icon = type === 'success' ? 'fa-check-circle' :
                    type === 'error' ? 'fa-exclamation-circle' :
                    type === 'warning' ? 'fa-exclamation-triangle' : 'fa-info-circle';
        
        toast.innerHTML = `
            <i class="fas ${icon}"></i>
            <span>${message}</span>
        `;
        
        toastContainer.appendChild(toast);
        
        // Auto remove after 5 seconds
        setTimeout(() => {
            if (toast.parentNode) {
                toast.parentNode.removeChild(toast);
            }
        }, 5000);
    }
    
    async showFallbackConfirmation() {
        return new Promise((resolve) => {
            const modal = document.createElement('div');
            modal.className = 'modal-overlay active';
            modal.innerHTML = `
                <div class="modal">
                    <div class="modal-header">
                        <div class="modal-icon warning">
                            <i class="fas fa-exclamation-triangle fa-2x"></i>
                        </div>
                        <h3 class="modal-title">OpenAI API Error</h3>
                    </div>
                    <div class="modal-content">
                        <p>The OpenAI API encountered an error while processing your request.</p>
                        <p>Would you like to:</p>
                        <ul style="list-style: none; padding: 0; margin: 1rem 0;">
                            <li style="margin: 0.5rem 0;">
                                <i class="fas fa-check-circle" style="color: #48bb78; margin-right: 0.5rem;"></i>
                                Use local VLM instead (processes on your GPU)
                            </li>
                            <li style="margin: 0.5rem 0;">
                                <i class="fas fa-times-circle" style="color: #e53e3e; margin-right: 0.5rem;"></i>
                                Cancel the operation
                            </li>
                        </ul>
                    </div>
                    <div class="modal-actions">
                        <button class="modal-btn primary" id="fallbackUseLocal">
                            <i class="fas fa-desktop"></i> Use Local VLM
                        </button>
                        <button class="modal-btn secondary" id="fallbackCancel">
                            <i class="fas fa-times"></i> Cancel
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Handle button clicks
            const useLocalBtn = modal.querySelector('#fallbackUseLocal');
            const cancelBtn = modal.querySelector('#fallbackCancel');
            
            const cleanup = () => {
                modal.classList.remove('active');
                setTimeout(() => modal.remove(), 300);
            };
            
            useLocalBtn.addEventListener('click', () => {
                cleanup();
                resolve(true);
            });
            
            cancelBtn.addEventListener('click', () => {
                cleanup();
                resolve(false);
            });
            
            // Handle escape key
            const handleEscape = (e) => {
                if (e.key === 'Escape') {
                    cleanup();
                    resolve(false);
                    document.removeEventListener('keydown', handleEscape);
                }
            };
            document.addEventListener('keydown', handleEscape);
        });
    }
}

// Privacy Modal Class
class PrivacyModal {
    constructor(app) {
        this.app = app;
        this.modal = document.getElementById('privacyModal');
        this.resolvePromise = null;
    }
    
    show() {
        return new Promise((resolve) => {
            this.resolvePromise = resolve;
            this.modal.classList.add('active');
        });
    }
    
    hide() {
        this.modal.classList.remove('active');
    }
    
    useLocal() {
        // Switch to local provider
        this.app.currentProvider = 'local';
        document.getElementById('providerSelect').value = 'local';
        this.app.updateProviderIndicator();
        this.app.handleProviderChange('local');
        
        this.hide();
        if (this.resolvePromise) {
            this.resolvePromise(false);
            this.resolvePromise = null;
        }
    }
    
    proceed() {
        // User acknowledged and wants to proceed with OpenAI
        this.hide();
        if (this.resolvePromise) {
            this.resolvePromise(true);
            this.resolvePromise = null;
        }
    }
    
    cancel() {
        // User cancelled the operation
        this.hide();
        if (this.resolvePromise) {
            this.resolvePromise(false);
            this.resolvePromise = null;
        }
    }
}

// Initialize the app when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    window.app = new VLMApp();
    
    // Update process button when custom query changes
    document.getElementById('customQuery').addEventListener('input', () => {
        window.app.updateProcessButton();
    });
});